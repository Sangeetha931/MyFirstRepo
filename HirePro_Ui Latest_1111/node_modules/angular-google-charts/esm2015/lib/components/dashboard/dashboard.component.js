import { ChangeDetectionStrategy, Component, ContentChildren, ElementRef, EventEmitter, Input, Output, QueryList } from '@angular/core';
import { combineLatest } from 'rxjs';
import { DataTableService } from '../../services/data-table.service';
import { ScriptLoaderService } from '../../services/script-loader.service';
import { ControlWrapperComponent } from '../control-wrapper/control-wrapper.component';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '../../services/script-loader.service';
import * as ɵngcc2 from '../../services/data-table.service';

const _c0 = ["*"];
export class DashboardComponent {
    constructor(element, loaderService, dataTableService) {
        this.element = element;
        this.loaderService = loaderService;
        this.dataTableService = dataTableService;
        /**
         * The dashboard has completed drawing and is ready to accept changes.
         *
         * The ready event will also fire:
         * - after the completion of a dashboard refresh triggered by a user or programmatic interaction with one of the controls,
         * - after redrawing any chart on the dashboard.
         */
        this.ready = new EventEmitter();
        /**
         * Emits when an error occurs when attempting to render the dashboard.
         * One or more of the controls and charts that are part of the dashboard may have failed rendering.
         */
        this.error = new EventEmitter();
        this.initialized = false;
    }
    ngOnInit() {
        this.loaderService.loadChartPackages('controls').subscribe(() => {
            this.dataTable = this.dataTableService.create(this.data, this.columns, this.formatters);
            this.createDashboard();
            this.initialized = true;
        });
    }
    ngOnChanges(changes) {
        if (!this.initialized) {
            return;
        }
        if (changes.data || changes.columns || changes.formatters) {
            this.dataTable = this.dataTableService.create(this.data, this.columns, this.formatters);
            this.dashboard.draw(this.dataTable);
        }
    }
    createDashboard() {
        // TODO: This should happen in the control wrapper
        // However, I don't yet know how to do this because then `bind()` would get called multiple times
        // for the same control if something changes. This is not supported by google charts as far as I can tell
        // from their source code.
        const controlWrappersReady$ = this.controlWrappers.map(control => control.wrapperReady$);
        const chartsReady$ = this.controlWrappers
            .map(control => control.for)
            .map(charts => {
            if (Array.isArray(charts)) {
                // CombineLatest waits for all observables
                return combineLatest(charts.map(chart => chart.wrapperReady$));
            }
            else {
                return charts.wrapperReady$;
            }
        });
        // We have to wait for all chart wrappers and control wrappers to be initialized
        // before we can compose them together to create the dashboard
        combineLatest([...controlWrappersReady$, ...chartsReady$]).subscribe(() => {
            this.dashboard = new google.visualization.Dashboard(this.element.nativeElement);
            this.initializeBindings();
            this.registerEvents();
            this.dashboard.draw(this.dataTable);
        });
    }
    registerEvents() {
        google.visualization.events.removeAllListeners(this.dashboard);
        const registerDashEvent = (object, eventName, callback) => {
            google.visualization.events.addListener(object, eventName, callback);
        };
        registerDashEvent(this.dashboard, 'ready', () => this.ready.emit());
        registerDashEvent(this.dashboard, 'error', (error) => this.error.emit(error));
    }
    initializeBindings() {
        this.controlWrappers.forEach(control => {
            if (Array.isArray(control.for)) {
                const chartWrappers = control.for.map(chart => chart.chartWrapper);
                this.dashboard.bind(control.controlWrapper, chartWrappers);
            }
            else {
                this.dashboard.bind(control.controlWrapper, control.for.chartWrapper);
            }
        });
    }
}
DashboardComponent.ɵfac = function DashboardComponent_Factory(t) { return new (t || DashboardComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.ScriptLoaderService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.DataTableService)); };
DashboardComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: DashboardComponent, selectors: [["dashboard"]], contentQueries: function DashboardComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ControlWrapperComponent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.controlWrappers = _t);
    } }, hostAttrs: [1, "dashboard"], inputs: { data: "data", columns: "columns", formatters: "formatters" }, outputs: { ready: "ready", error: "error" }, exportAs: ["dashboard"], features: [ɵngcc0.ɵɵNgOnChangesFeature], ngContentSelectors: _c0, decls: 1, vars: 0, template: function DashboardComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
DashboardComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ScriptLoaderService },
    { type: DataTableService }
];
DashboardComponent.propDecorators = {
    data: [{ type: Input }],
    columns: [{ type: Input }],
    formatters: [{ type: Input }],
    ready: [{ type: Output }],
    error: [{ type: Output }],
    controlWrappers: [{ type: ContentChildren, args: [ControlWrapperComponent,] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DashboardComponent, [{
        type: Component,
        args: [{
                selector: 'dashboard',
                template: '<ng-content></ng-content>',
                changeDetection: ChangeDetectionStrategy.OnPush,
                exportAs: 'dashboard',
                host: { class: 'dashboard' }
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc1.ScriptLoaderService }, { type: ɵngcc2.DataTableService }]; }, { ready: [{
            type: Output
        }], error: [{
            type: Output
        }], data: [{
            type: Input
        }], columns: [{
            type: Input
        }], formatters: [{
            type: Input
        }], controlWrappers: [{
            type: ContentChildren,
            args: [ControlWrapperComponent]
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGFzaGJvYXJkLmNvbXBvbmVudC5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vbGlicy9hbmd1bGFyLWdvb2dsZS1jaGFydHMvc3JjL2xpYi9jb21wb25lbnRzL2Rhc2hib2FyZC9kYXNoYm9hcmQuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCx1QkFBdUIsRUFDdkIsU0FBUyxFQUNULGVBQWUsRUFDZixVQUFVLEVBQ1YsWUFBWSxFQUNaLEtBQUssRUFHTCxNQUFNLEVBQ04sU0FBUyxFQUVWLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFFckMsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sbUNBQW1DLENBQUM7QUFDckUsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sc0NBQXNDLENBQUM7QUFJM0UsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sOENBQThDLENBQUM7Ozs7OztBQVN2RixNQUFNLE9BQU8sa0JBQWtCO0FBQUcsSUFtRGhDLFlBQ1UsT0FBbUIsRUFDbkIsYUFBa0MsRUFDbEMsZ0JBQWtDO0FBQzNDLFFBSFMsWUFBTyxHQUFQLE9BQU8sQ0FBWTtBQUFDLFFBQ3BCLGtCQUFhLEdBQWIsYUFBYSxDQUFxQjtBQUFDLFFBQ25DLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBa0I7QUFDOUMsUUE1QkU7QUFDRjtBQUVDO0FBQVc7QUFDTTtBQUNNO0FBR1osV0FGUDtBQUNMLFFBQ1MsVUFBSyxHQUFHLElBQUksWUFBWSxFQUFRLENBQUM7QUFDMUMsUUFDRTtBQUNGO0FBQ007QUFFQSxXQUREO0FBQ0wsUUFDUyxVQUFLLEdBQUcsSUFBSSxZQUFZLEVBQW1CLENBQUM7QUFDckQsUUFNVSxnQkFBVyxHQUFHLEtBQUssQ0FBQztBQUM5QixJQUtLLENBQUM7QUFDTixJQUNTLFFBQVE7QUFDakIsUUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDLGlC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QkFDVCxRQUFRLEVBQUUsV0FBVyxrQkFDckIsUUFBUSxFQUFFLDJCQUEyQixrQkFDckMsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU0sa0JBQy9DLFFBQVEsRUFBRTtJQUFXLGtCQUNyQixJQUFJLEVBQUUsRUFBRSxLQUFLLEVBQUUsV0FBVyxFQUFFLGNBQzdCOzs7Ozs7OztpREFDSTtBQUFDO0FBQTRDLFlBekJoRCxVQUFVO0FBQ1YsWUFXTyxtQkFBbUI7QUFBSSxZQUR2QixnQkFBZ0I7QUFBRztBQUFHO0FBQXNDLG1CQW9CbEUsS0FBSztBQUNOLHNCQVFDLEtBQUs7QUFDTix5QkFRQyxLQUFLO0FBQ04sb0JBU0MsTUFBTTtBQUNQLG9CQU1DLE1BQU07QUFDUCw4QkFFQyxlQUFlLFNBQUMsdUJBQXVCO0FBQ3RDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENvbXBvbmVudCxcbiAgQ29udGVudENoaWxkcmVuLFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBPbkNoYW5nZXMsXG4gIE9uSW5pdCxcbiAgT3V0cHV0LFxuICBRdWVyeUxpc3QsXG4gIFNpbXBsZUNoYW5nZXNcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBjb21iaW5lTGF0ZXN0IH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7IERhdGFUYWJsZVNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9kYXRhLXRhYmxlLnNlcnZpY2UnO1xuaW1wb3J0IHsgU2NyaXB0TG9hZGVyU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL3NjcmlwdC1sb2FkZXIuc2VydmljZSc7XG5pbXBvcnQgeyBDaGFydEVycm9yRXZlbnQgfSBmcm9tICcuLi8uLi90eXBlcy9ldmVudHMnO1xuaW1wb3J0IHsgRm9ybWF0dGVyIH0gZnJvbSAnLi4vLi4vdHlwZXMvZm9ybWF0dGVyJztcbmltcG9ydCB7IENvbHVtbiwgUm93IH0gZnJvbSAnLi4vY2hhcnQtYmFzZS9jaGFydC1iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBDb250cm9sV3JhcHBlckNvbXBvbmVudCB9IGZyb20gJy4uL2NvbnRyb2wtd3JhcHBlci9jb250cm9sLXdyYXBwZXIuY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnZGFzaGJvYXJkJyxcbiAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIGV4cG9ydEFzOiAnZGFzaGJvYXJkJyxcbiAgaG9zdDogeyBjbGFzczogJ2Rhc2hib2FyZCcgfVxufSlcbmV4cG9ydCBjbGFzcyBEYXNoYm9hcmRDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcyB7XG4gIC8qKlxuICAgKiBEYXRhIHVzZWQgdG8gaW5pdGlhbGl6ZSB0aGUgdGFibGUuXG4gICAqXG4gICAqIFRoaXMgbXVzdCBhbHNvIGNvbnRhaW4gYWxsIHJvbGVzIHRoYXQgYXJlIHNldCBpbiB0aGUgYGNvbHVtbnNgIHByb3BlcnR5LlxuICAgKi9cbiAgQElucHV0KClcbiAgcHVibGljIGRhdGEhOiBSb3dbXTtcblxuICAvKipcbiAgICogVGhlIGNvbHVtbnMgdGhlIGBkYXRhYCBjb25zaXN0cyBvZi5cbiAgICogVGhlIGxlbmd0aCBvZiB0aGlzIGFycmF5IG11c3QgbWF0Y2ggdGhlIGxlbmd0aCBvZiBlYWNoIHJvdyBpbiB0aGUgYGRhdGFgIG9iamVjdC5cbiAgICpcbiAgICogSWYge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL2NoYXJ0L2ludGVyYWN0aXZlL2RvY3Mvcm9sZXMgcm9sZXN9IHNob3VsZCBiZSBhcHBsaWVkLCB0aGV5IG11c3QgYmUgaW5jbHVkZWQgaW4gdGhpcyBhcnJheSBhcyB3ZWxsLlxuICAgKi9cbiAgQElucHV0KClcbiAgcHVibGljIGNvbHVtbnM/OiBDb2x1bW5bXTtcblxuICAvKipcbiAgICogVXNlZCB0byBjaGFuZ2UgdGhlIGRpc3BsYXllZCB2YWx1ZSBvZiB0aGUgc3BlY2lmaWVkIGNvbHVtbiBpbiBhbGwgcm93cy5cbiAgICpcbiAgICogRWFjaCBhcnJheSBlbGVtZW50IG11c3QgY29uc2lzdCBvZiBhbiBpbnN0YW5jZSBvZiBhIFtgZm9ybWF0dGVyYF0oaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vY2hhcnQvaW50ZXJhY3RpdmUvZG9jcy9yZWZlcmVuY2UjZm9ybWF0dGVycylcbiAgICogYW5kIHRoZSBpbmRleCBvZiB0aGUgY29sdW1uIHlvdSB3YW50IHRoZSBmb3JtYXR0ZXIgdG8gZ2V0IGFwcGxpZWQgdG8uXG4gICAqL1xuICBASW5wdXQoKVxuICBwdWJsaWMgZm9ybWF0dGVycz86IEZvcm1hdHRlcltdO1xuXG4gIC8qKlxuICAgKiBUaGUgZGFzaGJvYXJkIGhhcyBjb21wbGV0ZWQgZHJhd2luZyBhbmQgaXMgcmVhZHkgdG8gYWNjZXB0IGNoYW5nZXMuXG4gICAqXG4gICAqIFRoZSByZWFkeSBldmVudCB3aWxsIGFsc28gZmlyZTpcbiAgICogLSBhZnRlciB0aGUgY29tcGxldGlvbiBvZiBhIGRhc2hib2FyZCByZWZyZXNoIHRyaWdnZXJlZCBieSBhIHVzZXIgb3IgcHJvZ3JhbW1hdGljIGludGVyYWN0aW9uIHdpdGggb25lIG9mIHRoZSBjb250cm9scyxcbiAgICogLSBhZnRlciByZWRyYXdpbmcgYW55IGNoYXJ0IG9uIHRoZSBkYXNoYm9hcmQuXG4gICAqL1xuICBAT3V0cHV0KClcbiAgcHVibGljIHJlYWR5ID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gIC8qKlxuICAgKiBFbWl0cyB3aGVuIGFuIGVycm9yIG9jY3VycyB3aGVuIGF0dGVtcHRpbmcgdG8gcmVuZGVyIHRoZSBkYXNoYm9hcmQuXG4gICAqIE9uZSBvciBtb3JlIG9mIHRoZSBjb250cm9scyBhbmQgY2hhcnRzIHRoYXQgYXJlIHBhcnQgb2YgdGhlIGRhc2hib2FyZCBtYXkgaGF2ZSBmYWlsZWQgcmVuZGVyaW5nLlxuICAgKi9cbiAgQE91dHB1dCgpXG4gIHB1YmxpYyBlcnJvciA9IG5ldyBFdmVudEVtaXR0ZXI8Q2hhcnRFcnJvckV2ZW50PigpO1xuXG4gIEBDb250ZW50Q2hpbGRyZW4oQ29udHJvbFdyYXBwZXJDb21wb25lbnQpXG4gIHByaXZhdGUgY29udHJvbFdyYXBwZXJzITogUXVlcnlMaXN0PENvbnRyb2xXcmFwcGVyQ29tcG9uZW50PjtcblxuICBwcml2YXRlIGRhc2hib2FyZD86IGdvb2dsZS52aXN1YWxpemF0aW9uLkRhc2hib2FyZDtcbiAgcHJpdmF0ZSBkYXRhVGFibGU/OiBnb29nbGUudmlzdWFsaXphdGlvbi5EYXRhVGFibGU7XG4gIHByaXZhdGUgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGVsZW1lbnQ6IEVsZW1lbnRSZWYsXG4gICAgcHJpdmF0ZSBsb2FkZXJTZXJ2aWNlOiBTY3JpcHRMb2FkZXJTZXJ2aWNlLFxuICAgIHByaXZhdGUgZGF0YVRhYmxlU2VydmljZTogRGF0YVRhYmxlU2VydmljZVxuICApIHt9XG5cbiAgcHVibGljIG5nT25Jbml0KCkge1xuICAgIHRoaXMubG9hZGVyU2VydmljZS5sb2FkQ2hhcnRQYWNrYWdlcygnY29udHJvbHMnKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy5kYXRhVGFibGUgPSB0aGlzLmRhdGFUYWJsZVNlcnZpY2UuY3JlYXRlKHRoaXMuZGF0YSwgdGhpcy5jb2x1bW5zLCB0aGlzLmZvcm1hdHRlcnMpO1xuICAgICAgdGhpcy5jcmVhdGVEYXNoYm9hcmQoKTtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY2hhbmdlcy5kYXRhIHx8IGNoYW5nZXMuY29sdW1ucyB8fCBjaGFuZ2VzLmZvcm1hdHRlcnMpIHtcbiAgICAgIHRoaXMuZGF0YVRhYmxlID0gdGhpcy5kYXRhVGFibGVTZXJ2aWNlLmNyZWF0ZSh0aGlzLmRhdGEsIHRoaXMuY29sdW1ucywgdGhpcy5mb3JtYXR0ZXJzKTtcbiAgICAgIHRoaXMuZGFzaGJvYXJkIS5kcmF3KHRoaXMuZGF0YVRhYmxlISk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjcmVhdGVEYXNoYm9hcmQoKTogdm9pZCB7XG4gICAgLy8gVE9ETzogVGhpcyBzaG91bGQgaGFwcGVuIGluIHRoZSBjb250cm9sIHdyYXBwZXJcbiAgICAvLyBIb3dldmVyLCBJIGRvbid0IHlldCBrbm93IGhvdyB0byBkbyB0aGlzIGJlY2F1c2UgdGhlbiBgYmluZCgpYCB3b3VsZCBnZXQgY2FsbGVkIG11bHRpcGxlIHRpbWVzXG4gICAgLy8gZm9yIHRoZSBzYW1lIGNvbnRyb2wgaWYgc29tZXRoaW5nIGNoYW5nZXMuIFRoaXMgaXMgbm90IHN1cHBvcnRlZCBieSBnb29nbGUgY2hhcnRzIGFzIGZhciBhcyBJIGNhbiB0ZWxsXG4gICAgLy8gZnJvbSB0aGVpciBzb3VyY2UgY29kZS5cbiAgICBjb25zdCBjb250cm9sV3JhcHBlcnNSZWFkeSQgPSB0aGlzLmNvbnRyb2xXcmFwcGVycy5tYXAoY29udHJvbCA9PiBjb250cm9sLndyYXBwZXJSZWFkeSQpO1xuICAgIGNvbnN0IGNoYXJ0c1JlYWR5JCA9IHRoaXMuY29udHJvbFdyYXBwZXJzXG4gICAgICAubWFwKGNvbnRyb2wgPT4gY29udHJvbC5mb3IpXG4gICAgICAubWFwKGNoYXJ0cyA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoYXJ0cykpIHtcbiAgICAgICAgICAvLyBDb21iaW5lTGF0ZXN0IHdhaXRzIGZvciBhbGwgb2JzZXJ2YWJsZXNcbiAgICAgICAgICByZXR1cm4gY29tYmluZUxhdGVzdChjaGFydHMubWFwKGNoYXJ0ID0+IGNoYXJ0LndyYXBwZXJSZWFkeSQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY2hhcnRzLndyYXBwZXJSZWFkeSQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgLy8gV2UgaGF2ZSB0byB3YWl0IGZvciBhbGwgY2hhcnQgd3JhcHBlcnMgYW5kIGNvbnRyb2wgd3JhcHBlcnMgdG8gYmUgaW5pdGlhbGl6ZWRcbiAgICAvLyBiZWZvcmUgd2UgY2FuIGNvbXBvc2UgdGhlbSB0b2dldGhlciB0byBjcmVhdGUgdGhlIGRhc2hib2FyZFxuICAgIGNvbWJpbmVMYXRlc3QoWy4uLmNvbnRyb2xXcmFwcGVyc1JlYWR5JCwgLi4uY2hhcnRzUmVhZHkkXSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgIHRoaXMuZGFzaGJvYXJkID0gbmV3IGdvb2dsZS52aXN1YWxpemF0aW9uLkRhc2hib2FyZCh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgICB0aGlzLmluaXRpYWxpemVCaW5kaW5ncygpO1xuICAgICAgdGhpcy5yZWdpc3RlckV2ZW50cygpO1xuICAgICAgdGhpcy5kYXNoYm9hcmQuZHJhdyh0aGlzLmRhdGFUYWJsZSEpO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSByZWdpc3RlckV2ZW50cygpOiB2b2lkIHtcbiAgICBnb29nbGUudmlzdWFsaXphdGlvbi5ldmVudHMucmVtb3ZlQWxsTGlzdGVuZXJzKHRoaXMuZGFzaGJvYXJkKTtcblxuICAgIGNvbnN0IHJlZ2lzdGVyRGFzaEV2ZW50ID0gKG9iamVjdDogYW55LCBldmVudE5hbWU6IHN0cmluZywgY2FsbGJhY2s6IEZ1bmN0aW9uKSA9PiB7XG4gICAgICBnb29nbGUudmlzdWFsaXphdGlvbi5ldmVudHMuYWRkTGlzdGVuZXIob2JqZWN0LCBldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgcmVnaXN0ZXJEYXNoRXZlbnQodGhpcy5kYXNoYm9hcmQsICdyZWFkeScsICgpID0+IHRoaXMucmVhZHkuZW1pdCgpKTtcbiAgICByZWdpc3RlckRhc2hFdmVudCh0aGlzLmRhc2hib2FyZCwgJ2Vycm9yJywgKGVycm9yOiBDaGFydEVycm9yRXZlbnQpID0+IHRoaXMuZXJyb3IuZW1pdChlcnJvcikpO1xuICB9XG5cbiAgcHJpdmF0ZSBpbml0aWFsaXplQmluZGluZ3MoKTogdm9pZCB7XG4gICAgdGhpcy5jb250cm9sV3JhcHBlcnMuZm9yRWFjaChjb250cm9sID0+IHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbnRyb2wuZm9yKSkge1xuICAgICAgICBjb25zdCBjaGFydFdyYXBwZXJzID0gY29udHJvbC5mb3IubWFwKGNoYXJ0ID0+IGNoYXJ0LmNoYXJ0V3JhcHBlcik7XG4gICAgICAgIHRoaXMuZGFzaGJvYXJkIS5iaW5kKGNvbnRyb2wuY29udHJvbFdyYXBwZXIsIGNoYXJ0V3JhcHBlcnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kYXNoYm9hcmQhLmJpbmQoY29udHJvbC5jb250cm9sV3JhcHBlciwgY29udHJvbC5mb3IuY2hhcnRXcmFwcGVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuIl19