import { __rest } from "tslib";
import { ChangeDetectionStrategy, Component, ElementRef, EventEmitter, Input, Output } from '@angular/core';
import { ReplaySubject } from 'rxjs';
import { ScriptLoaderService } from '../../services/script-loader.service';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '../../services/script-loader.service';
export class ChartWrapperComponent {
    constructor(element, scriptLoaderService) {
        this.element = element;
        this.scriptLoaderService = scriptLoaderService;
        this.error = new EventEmitter();
        this.ready = new EventEmitter();
        this.select = new EventEmitter();
        this.wrapperReadySubject = new ReplaySubject(1);
        this.initialized = false;
    }
    get chart() {
        return this.chartWrapper.getChart();
    }
    get wrapperReady$() {
        return this.wrapperReadySubject.asObservable();
    }
    get chartWrapper() {
        if (!this.wrapper) {
            throw new Error('Cannot access the chart wrapper before initialization.');
        }
        return this.wrapper;
    }
    set chartWrapper(wrapper) {
        this.wrapper = wrapper;
        this.drawChart();
    }
    ngOnInit() {
        // We don't need to load any chart packages, the chart wrapper will handle this else for us
        this.scriptLoaderService.loadChartPackages().subscribe(() => {
            if (!this.specs) {
                this.specs = {};
            }
            const _a = this.specs, { containerId, container } = _a, specs = __rest(_a, ["containerId", "container"]);
            // Only ever create the wrapper once to allow animations to happen if something changes.
            this.wrapper = new google.visualization.ChartWrapper(Object.assign(Object.assign({}, specs), { container: this.element.nativeElement }));
            this.registerChartEvents();
            this.wrapperReadySubject.next(this.wrapper);
            this.drawChart();
            this.initialized = true;
        });
    }
    ngOnChanges(changes) {
        if (!this.initialized) {
            return;
        }
        if (changes.specs) {
            this.updateChart();
            this.drawChart();
        }
    }
    updateChart() {
        if (!this.specs) {
            // When creating the wrapper with empty specs, the google charts library will show an error
            // If we don't do this, a javascript error will be thrown, which is not as visible to the user
            this.specs = {};
        }
        // The typing here are not correct. These methods accept `undefined` as well.
        // That's why we have to cast to `any`
        this.wrapper.setChartType(this.specs.chartType);
        this.wrapper.setDataTable(this.specs.dataTable);
        this.wrapper.setDataSourceUrl(this.specs.dataSourceUrl);
        this.wrapper.setDataSourceUrl(this.specs.dataSourceUrl);
        this.wrapper.setQuery(this.specs.query);
        this.wrapper.setOptions(this.specs.options);
        this.wrapper.setRefreshInterval(this.specs.refreshInterval);
        this.wrapper.setView(this.specs.view);
    }
    drawChart() {
        if (this.wrapper) {
            this.wrapper.draw();
        }
    }
    registerChartEvents() {
        google.visualization.events.removeAllListeners(this.wrapper);
        const registerChartEvent = (object, eventName, callback) => {
            google.visualization.events.addListener(object, eventName, callback);
        };
        registerChartEvent(this.wrapper, 'ready', () => this.ready.emit({ chart: this.chart }));
        registerChartEvent(this.wrapper, 'error', (error) => this.error.emit(error));
        registerChartEvent(this.wrapper, 'select', () => {
            const selection = this.chart.getSelection();
            this.select.emit({ selection });
        });
    }
}
ChartWrapperComponent.ɵfac = function ChartWrapperComponent_Factory(t) { return new (t || ChartWrapperComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.ScriptLoaderService)); };
ChartWrapperComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ChartWrapperComponent, selectors: [["chart-wrapper"]], hostAttrs: [1, "chart-wrapper"], inputs: { specs: "specs" }, outputs: { error: "error", ready: "ready", select: "select" }, exportAs: ["chartWrapper"], features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 0, vars: 0, template: function ChartWrapperComponent_Template(rf, ctx) { }, styles: ["[_nghost-%COMP%] { width: fit-content; display: block; }"], changeDetection: 0 });
ChartWrapperComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ScriptLoaderService }
];
ChartWrapperComponent.propDecorators = {
    specs: [{ type: Input }],
    error: [{ type: Output }],
    ready: [{ type: Output }],
    select: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ChartWrapperComponent, [{
        type: Component,
        args: [{
                selector: 'chart-wrapper',
                template: '',
                host: { class: 'chart-wrapper' },
                exportAs: 'chartWrapper',
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [':host { width: fit-content; display: block; }']
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc1.ScriptLoaderService }]; }, { error: [{
            type: Output
        }], ready: [{
            type: Output
        }], select: [{
            type: Output
        }], specs: [{
            type: Input
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hhcnQtd3JhcHBlci5jb21wb25lbnQuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL2xpYnMvYW5ndWxhci1nb29nbGUtY2hhcnRzL3NyYy9saWIvY29tcG9uZW50cy9jaGFydC13cmFwcGVyL2NoYXJ0LXdyYXBwZXIuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQ0wsdUJBQXVCLEVBQ3ZCLFNBQVMsRUFDVCxVQUFVLEVBQ1YsWUFBWSxFQUNaLEtBQUssRUFHTCxNQUFNLEVBRVAsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUVyQyxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxzQ0FBc0MsQ0FBQzs7O0FBWTNFLE1BQU0sT0FBTyxxQkFBcUI7QUFBRyxJQXlCbkMsWUFBb0IsT0FBbUIsRUFBVSxtQkFBd0M7QUFBSSxRQUF6RSxZQUFPLEdBQVAsT0FBTyxDQUFZO0FBQUMsUUFBUyx3QkFBbUIsR0FBbkIsbUJBQW1CLENBQXFCO0FBQUMsUUFabkYsVUFBSyxHQUFHLElBQUksWUFBWSxFQUFtQixDQUFDO0FBQ3JELFFBRVMsVUFBSyxHQUFHLElBQUksWUFBWSxFQUFtQixDQUFDO0FBQ3JELFFBRVMsV0FBTSxHQUFHLElBQUksWUFBWSxFQUE4QixDQUFDO0FBQ2pFLFFBRVUsd0JBQW1CLEdBQUcsSUFBSSxhQUFhLENBQW9DLENBQUMsQ0FBQyxDQUFDO0FBQ3hGLFFBQVUsZ0JBQVcsR0FBRyxLQUFLLENBQUM7QUFDOUIsSUFDOEYsQ0FBQztBQUMvRixJQUNFLElBQVcsS0FBSztBQUFLLFFBQ25CLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRLEVBQUUsQ0FBQztBQUN4QyxJQUFFLENBQUM7QUFDSCxJQUNFLElBQVcsYUFBYTtBQUMxQixRQUFJLE9BQU8sSUFBSSxDQUFDLG1CQUFtQixDQUFDLFlBQVksRUFBRSxDQUFDO0FBQ25ELElBQUUsQ0FBQztBQUNILElBQ0UsSUFBVyxZQUFZO0FBQUssUUFDMUIsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUU7QUFDdkIsWUFBTSxNQUFNLElBQUksS0FBSyxDQUFDLHdEQUF3RCxDQUFDLENBQUM7QUFDaEYsU0FBSztBQUNMLFFBQ0ksT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDO0FBQ3hCLElBQUUsQ0FBQztBQUNILElBQ0UsSUFBVyxZQUFZLENBQUMsT0FBMEM7QUFDcEUsUUFBSSxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztBQUMzQixRQUFJLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztBQUNyQixJQUFFLENBQUM7QUFDSCxJQUNTLFFBQVE7QUFDakIsUUFBSSwyRkFBMkY7QUFDL0YsUUFBSSxJQUFJLENBQUMsbUJBQW1CLENBQUMsaUJBQWlCLEVBQUUsQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFO0FBQ2hFLFlBQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUU7QUFDdkIsZ0JBQVEsSUFBSSxDQUFDLEtBQUssR0FBRyxFQUFxQyxDQUFDO0FBQzNELGFBQU87QUFDUCxZQUNNLE1BQU0sS0FBdUMsSUFBSSxDQUFDLEtBQUssRUFBakQsRUFBRSxXQUFXLEVBQUUsU0FBUyxPQUF5QixFQUFwQixLQUFLLGNBQWxDLDRCQUFvQyxDQUFhLENBQUM7QUFDOUQsWUFDTSx3RkFBd0Y7QUFDOUYsWUFBTSxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksTUFBTSxDQUFDLGFBQWEsQ0FBQyxZQUFZLGlDQUMvQyxLQUFLLEtBQ1IsU0FBUyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxJQUNyQyxDQUFDO0FBQ1QsWUFBTSxJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztBQUNqQyxZQUNNLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQ2xELFlBQ00sSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO0FBQ3ZCLFlBQU0sSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUM7QUFDOUIsUUFBSSxDQUFDLENBQUMsQ0FBQztBQUNQLElBQUUsQ0FBQztBQUNILElBQ1MsV0FBVyxDQUFDLE9BQXNCO0FBQzNDLFFBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUU7QUFDM0IsWUFBTSxPQUFPO0FBQ2IsU0FBSztBQUNMLFFBQ0ksSUFBSSxPQUFPLENBQUMsS0FBSyxFQUFFO0FBQ3ZCLFlBQU0sSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO0FBQ3pCLFlBQU0sSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO0FBQ3ZCLFNBQUs7QUFDTCxJQUFFLENBQUM7QUFDSCxJQUNVLFdBQVc7QUFDckIsUUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRTtBQUNyQixZQUFNLDJGQUEyRjtBQUNqRyxZQUFNLDhGQUE4RjtBQUNwRyxZQUFNLElBQUksQ0FBQyxLQUFLLEdBQUcsRUFBcUMsQ0FBQztBQUN6RCxTQUFLO0FBQ0wsUUFDSSw2RUFBNkU7QUFDakYsUUFBSSxzQ0FBc0M7QUFDMUMsUUFDSSxJQUFJLENBQUMsT0FBUSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQ3JELFFBQUksSUFBSSxDQUFDLE9BQVEsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFnQixDQUFDLENBQUM7QUFDNUQsUUFBSSxJQUFJLENBQUMsT0FBUSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBb0IsQ0FBQyxDQUFDO0FBQ3BFLFFBQUksSUFBSSxDQUFDLE9BQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLGFBQW9CLENBQUMsQ0FBQztBQUNwRSxRQUFJLElBQUksQ0FBQyxPQUFRLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBWSxDQUFDLENBQUM7QUFDcEQsUUFBSSxJQUFJLENBQUMsT0FBUSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQWMsQ0FBQyxDQUFDO0FBQ3hELFFBQUksSUFBSSxDQUFDLE9BQVEsQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLGVBQXNCLENBQUMsQ0FBQztBQUN4RSxRQUFJLElBQUksQ0FBQyxPQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDM0MsSUFBRSxDQUFDO0FBQ0gsSUFDVSxTQUFTO0FBQ25CLFFBQUksSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFO0FBQ3RCLFlBQU0sSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQztBQUMxQixTQUFLO0FBQ0wsSUFBRSxDQUFDO0FBQ0gsSUFDVSxtQkFBbUI7QUFDN0IsUUFBSSxNQUFNLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDakUsUUFDSSxNQUFNLGtCQUFrQixHQUFHLENBQUMsTUFBVyxFQUFFLFNBQWlCLEVBQUUsUUFBa0IsRUFBRSxFQUFFO0FBQ3RGLFlBQU0sTUFBTSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUUsUUFBUSxDQUFDLENBQUM7QUFDM0UsUUFBSSxDQUFDLENBQUM7QUFDTixRQUNJLGtCQUFrQixDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDN0YsUUFBSSxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxDQUFDLEtBQXNCLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDbEcsUUFBSSxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUU7QUFDcEQsWUFBTSxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBTSxDQUFDLFlBQVksRUFBRSxDQUFDO0FBQ25ELFlBQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDO0FBQ3RDLFFBQUksQ0FBQyxDQUFDLENBQUM7QUFDUCxJQUFFLENBQUM7QUFDSDtpREFsSUMsU0FBUyxTQUFDLGtCQUNULFFBQVEsRUFBRSxlQUFlLGtCQUN6QixRQUFRLEVBQUUsRUFBRSxrQkFFWixJQUFJLEVBQUUsRUFBRSxLQUFLLEVBQUUsZUFBZSxFQUFFLGtCQUNoQztBQUFRLEVBQUUsY0FBYyxrQkFDeEIsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU0sMkJBSHRDLCtDQUErQyxlQUl6RCwyVEFDSTtBQUFDO0FBQStDLFlBdEJuRCxVQUFVO0FBQ1YsWUFTTyxtQkFBbUI7QUFBRztBQUFHO0FBQXlDLG9CQXFCeEUsS0FBSztBQUNOLG9CQUVDLE1BQU07QUFDUCxvQkFFQyxNQUFNO0FBQ1AscUJBRUMsTUFBTTtBQUNSOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFFO0FBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ29tcG9uZW50LFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBPbkNoYW5nZXMsXG4gIE9uSW5pdCxcbiAgT3V0cHV0LFxuICBTaW1wbGVDaGFuZ2VzXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUmVwbGF5U3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBTY3JpcHRMb2FkZXJTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvc2NyaXB0LWxvYWRlci5zZXJ2aWNlJztcbmltcG9ydCB7IENoYXJ0RXJyb3JFdmVudCwgQ2hhcnRSZWFkeUV2ZW50LCBDaGFydFNlbGVjdGlvbkNoYW5nZWRFdmVudCB9IGZyb20gJy4uLy4uL3R5cGVzL2V2ZW50cyc7XG5pbXBvcnQgeyBDaGFydEJhc2UgfSBmcm9tICcuLi9jaGFydC1iYXNlL2NoYXJ0LWJhc2UuY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2hhcnQtd3JhcHBlcicsXG4gIHRlbXBsYXRlOiAnJyxcbiAgc3R5bGVzOiBbJzpob3N0IHsgd2lkdGg6IGZpdC1jb250ZW50OyBkaXNwbGF5OiBibG9jazsgfSddLFxuICBob3N0OiB7IGNsYXNzOiAnY2hhcnQtd3JhcHBlcicgfSxcbiAgZXhwb3J0QXM6ICdjaGFydFdyYXBwZXInLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBDaGFydFdyYXBwZXJDb21wb25lbnQgaW1wbGVtZW50cyBDaGFydEJhc2UsIE9uQ2hhbmdlcywgT25Jbml0IHtcbiAgLyoqXG4gICAqIEVpdGhlciBhIEpTT04gb2JqZWN0IGRlZmluaW5nIHRoZSBjaGFydCwgb3IgYSBzZXJpYWxpemVkIHN0cmluZyB2ZXJzaW9uIG9mIHRoYXQgb2JqZWN0LlxuICAgKiBUaGUgZm9ybWF0IG9mIHRoaXMgb2JqZWN0IGlzIHNob3duIGluIHRoZVxuICAgKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vY2hhcnQvaW50ZXJhY3RpdmUvZG9jcy9yZWZlcmVuY2UjZ29vZ2xlLnZpc3VhbGl6YXRpb24uZHJhd2NoYXJ0IGBkcmF3Q2hhcnQoKWB9IGRvY3VtZW50YXRpb24uXG4gICAqXG4gICAqIFRoZSBgY29udGFpbmVyYCBhbmQgYGNvbnRhaW5lcklkYCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHRoaXMgY29tcG9uZW50IHRvIGFsbG93XG4gICAqIHJlbmRlcmluZyB0aGUgY2hhcnQgaW50byB0aGUgY29tcG9uZW50cycgdGVtcGxhdGUuXG4gICAqL1xuICBASW5wdXQoKVxuICBwdWJsaWMgc3BlY3M/OiBnb29nbGUudmlzdWFsaXphdGlvbi5DaGFydFNwZWNzO1xuXG4gIEBPdXRwdXQoKVxuICBwdWJsaWMgZXJyb3IgPSBuZXcgRXZlbnRFbWl0dGVyPENoYXJ0RXJyb3JFdmVudD4oKTtcblxuICBAT3V0cHV0KClcbiAgcHVibGljIHJlYWR5ID0gbmV3IEV2ZW50RW1pdHRlcjxDaGFydFJlYWR5RXZlbnQ+KCk7XG5cbiAgQE91dHB1dCgpXG4gIHB1YmxpYyBzZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyPENoYXJ0U2VsZWN0aW9uQ2hhbmdlZEV2ZW50PigpO1xuXG4gIHByaXZhdGUgd3JhcHBlcjogZ29vZ2xlLnZpc3VhbGl6YXRpb24uQ2hhcnRXcmFwcGVyIHwgdW5kZWZpbmVkO1xuICBwcml2YXRlIHdyYXBwZXJSZWFkeVN1YmplY3QgPSBuZXcgUmVwbGF5U3ViamVjdDxnb29nbGUudmlzdWFsaXphdGlvbi5DaGFydFdyYXBwZXI+KDEpO1xuICBwcml2YXRlIGluaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBlbGVtZW50OiBFbGVtZW50UmVmLCBwcml2YXRlIHNjcmlwdExvYWRlclNlcnZpY2U6IFNjcmlwdExvYWRlclNlcnZpY2UpIHt9XG5cbiAgcHVibGljIGdldCBjaGFydCgpOiBnb29nbGUudmlzdWFsaXphdGlvbi5DaGFydEJhc2UgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydFdyYXBwZXIuZ2V0Q2hhcnQoKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgd3JhcHBlclJlYWR5JCgpIHtcbiAgICByZXR1cm4gdGhpcy53cmFwcGVyUmVhZHlTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICB9XG5cbiAgcHVibGljIGdldCBjaGFydFdyYXBwZXIoKTogZ29vZ2xlLnZpc3VhbGl6YXRpb24uQ2hhcnRXcmFwcGVyIHtcbiAgICBpZiAoIXRoaXMud3JhcHBlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYWNjZXNzIHRoZSBjaGFydCB3cmFwcGVyIGJlZm9yZSBpbml0aWFsaXphdGlvbi4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy53cmFwcGVyO1xuICB9XG5cbiAgcHVibGljIHNldCBjaGFydFdyYXBwZXIod3JhcHBlcjogZ29vZ2xlLnZpc3VhbGl6YXRpb24uQ2hhcnRXcmFwcGVyKSB7XG4gICAgdGhpcy53cmFwcGVyID0gd3JhcHBlcjtcbiAgICB0aGlzLmRyYXdDaGFydCgpO1xuICB9XG5cbiAgcHVibGljIG5nT25Jbml0KCkge1xuICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gbG9hZCBhbnkgY2hhcnQgcGFja2FnZXMsIHRoZSBjaGFydCB3cmFwcGVyIHdpbGwgaGFuZGxlIHRoaXMgZWxzZSBmb3IgdXNcbiAgICB0aGlzLnNjcmlwdExvYWRlclNlcnZpY2UubG9hZENoYXJ0UGFja2FnZXMoKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnNwZWNzKSB7XG4gICAgICAgIHRoaXMuc3BlY3MgPSB7fSBhcyBnb29nbGUudmlzdWFsaXphdGlvbi5DaGFydFNwZWNzO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7IGNvbnRhaW5lcklkLCBjb250YWluZXIsIC4uLnNwZWNzIH0gPSB0aGlzLnNwZWNzO1xuXG4gICAgICAvLyBPbmx5IGV2ZXIgY3JlYXRlIHRoZSB3cmFwcGVyIG9uY2UgdG8gYWxsb3cgYW5pbWF0aW9ucyB0byBoYXBwZW4gaWYgc29tZXRoaW5nIGNoYW5nZXMuXG4gICAgICB0aGlzLndyYXBwZXIgPSBuZXcgZ29vZ2xlLnZpc3VhbGl6YXRpb24uQ2hhcnRXcmFwcGVyKHtcbiAgICAgICAgLi4uc3BlY3MsXG4gICAgICAgIGNvbnRhaW5lcjogdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnRcbiAgICAgIH0pO1xuICAgICAgdGhpcy5yZWdpc3RlckNoYXJ0RXZlbnRzKCk7XG5cbiAgICAgIHRoaXMud3JhcHBlclJlYWR5U3ViamVjdC5uZXh0KHRoaXMud3JhcHBlcik7XG5cbiAgICAgIHRoaXMuZHJhd0NoYXJ0KCk7XG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNoYW5nZXMuc3BlY3MpIHtcbiAgICAgIHRoaXMudXBkYXRlQ2hhcnQoKTtcbiAgICAgIHRoaXMuZHJhd0NoYXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVDaGFydCgpIHtcbiAgICBpZiAoIXRoaXMuc3BlY3MpIHtcbiAgICAgIC8vIFdoZW4gY3JlYXRpbmcgdGhlIHdyYXBwZXIgd2l0aCBlbXB0eSBzcGVjcywgdGhlIGdvb2dsZSBjaGFydHMgbGlicmFyeSB3aWxsIHNob3cgYW4gZXJyb3JcbiAgICAgIC8vIElmIHdlIGRvbid0IGRvIHRoaXMsIGEgamF2YXNjcmlwdCBlcnJvciB3aWxsIGJlIHRocm93biwgd2hpY2ggaXMgbm90IGFzIHZpc2libGUgdG8gdGhlIHVzZXJcbiAgICAgIHRoaXMuc3BlY3MgPSB7fSBhcyBnb29nbGUudmlzdWFsaXphdGlvbi5DaGFydFNwZWNzO1xuICAgIH1cblxuICAgIC8vIFRoZSB0eXBpbmcgaGVyZSBhcmUgbm90IGNvcnJlY3QuIFRoZXNlIG1ldGhvZHMgYWNjZXB0IGB1bmRlZmluZWRgIGFzIHdlbGwuXG4gICAgLy8gVGhhdCdzIHdoeSB3ZSBoYXZlIHRvIGNhc3QgdG8gYGFueWBcblxuICAgIHRoaXMud3JhcHBlciEuc2V0Q2hhcnRUeXBlKHRoaXMuc3BlY3MuY2hhcnRUeXBlKTtcbiAgICB0aGlzLndyYXBwZXIhLnNldERhdGFUYWJsZSh0aGlzLnNwZWNzLmRhdGFUYWJsZSBhcyBhbnkpO1xuICAgIHRoaXMud3JhcHBlciEuc2V0RGF0YVNvdXJjZVVybCh0aGlzLnNwZWNzLmRhdGFTb3VyY2VVcmwgYXMgYW55KTtcbiAgICB0aGlzLndyYXBwZXIhLnNldERhdGFTb3VyY2VVcmwodGhpcy5zcGVjcy5kYXRhU291cmNlVXJsIGFzIGFueSk7XG4gICAgdGhpcy53cmFwcGVyIS5zZXRRdWVyeSh0aGlzLnNwZWNzLnF1ZXJ5IGFzIGFueSk7XG4gICAgdGhpcy53cmFwcGVyIS5zZXRPcHRpb25zKHRoaXMuc3BlY3Mub3B0aW9ucyBhcyBhbnkpO1xuICAgIHRoaXMud3JhcHBlciEuc2V0UmVmcmVzaEludGVydmFsKHRoaXMuc3BlY3MucmVmcmVzaEludGVydmFsIGFzIGFueSk7XG4gICAgdGhpcy53cmFwcGVyIS5zZXRWaWV3KHRoaXMuc3BlY3Mudmlldyk7XG4gIH1cblxuICBwcml2YXRlIGRyYXdDaGFydCgpIHtcbiAgICBpZiAodGhpcy53cmFwcGVyKSB7XG4gICAgICB0aGlzLndyYXBwZXIuZHJhdygpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcmVnaXN0ZXJDaGFydEV2ZW50cygpIHtcbiAgICBnb29nbGUudmlzdWFsaXphdGlvbi5ldmVudHMucmVtb3ZlQWxsTGlzdGVuZXJzKHRoaXMud3JhcHBlcik7XG5cbiAgICBjb25zdCByZWdpc3RlckNoYXJ0RXZlbnQgPSAob2JqZWN0OiBhbnksIGV2ZW50TmFtZTogc3RyaW5nLCBjYWxsYmFjazogRnVuY3Rpb24pID0+IHtcbiAgICAgIGdvb2dsZS52aXN1YWxpemF0aW9uLmV2ZW50cy5hZGRMaXN0ZW5lcihvYmplY3QsIGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICByZWdpc3RlckNoYXJ0RXZlbnQodGhpcy53cmFwcGVyLCAncmVhZHknLCAoKSA9PiB0aGlzLnJlYWR5LmVtaXQoeyBjaGFydDogdGhpcy5jaGFydCEgfSkpO1xuICAgIHJlZ2lzdGVyQ2hhcnRFdmVudCh0aGlzLndyYXBwZXIsICdlcnJvcicsIChlcnJvcjogQ2hhcnRFcnJvckV2ZW50KSA9PiB0aGlzLmVycm9yLmVtaXQoZXJyb3IpKTtcbiAgICByZWdpc3RlckNoYXJ0RXZlbnQodGhpcy53cmFwcGVyLCAnc2VsZWN0JywgKCkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gdGhpcy5jaGFydCEuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICB0aGlzLnNlbGVjdC5lbWl0KHsgc2VsZWN0aW9uIH0pO1xuICAgIH0pO1xuICB9XG59XG4iXX0=